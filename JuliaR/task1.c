//Подключение стандартной библиотеки для осуществления ввода и вывода информации
#include <stdio.h>
//Подключение стандарнтой математической бибилотеки для получения доступа к математическим функциям
#include <math.h>

//Прототип функции, вычисляющей значение ряда. Данная функция принимает вещественный аргумент и указатель на целочисленный аргумент
float firstSeries(float, int *);
//Прототип функции, вычисляющей значение бесконечной дроби. Данная функция принимает вещественный аргумент и указатель на целочисленный аргумент
float secondSeries(float, int *);
//Прототип функции, вычисляющее значение бесконечной дроби с заданной длиной. Данная функция принимает вещественный аргумент
float infFrac(int);

//Точка входа в основную функцию
int main()
{
//Объявление вещественных переменных е - погрешность вычислений и sum - относительное значение ряда (по умолчанию 0)
	float e, sum = 0;
//Объявление целочисленной переменной i - итерация вычислений (по умолчанию 0)
	int i = 1;
//Точка входа в цикл с постусловием - запрос точности
	do {
//Вывод сообщения о запросе на ввод точности
		printf("Введите точность: ");
//Запрос на ввод точности
		scanf("%f", &e);
//В случае некорректного ввода выводится сообщение об ошибке
		if (e <= 0) printf("Ошибка: точность должна быть положительной\n");
//Цикл выполняется, пока выполняется данное условие
	} while (e <= 0);
//Вызов функции, вычисляющей относительное значение методом ряда
	sum = firstSeries(e, &i);
//Вывод полученной информации
	printf("Число \"е\" в виде ряда\nАбсолютное значение: %f\nОтносительное значение: %f\nИтерация получения значения: %d\nПогрешность вычислений: %f\n\n", exp(1), sum, i, e);
//Обнуление счетчика итераций
	i = 1;
//Вызов функции, вычисляющей относительное значение методом бесконечной дроби
	sum = secondSeries(e, &i);
//Вывод полученной информации
	printf("Число \"е\" в виде бесконечной дроби\nАбсолютное значение: %f\nОтносительное значение: %f\nИтерация получения значения: %d\nПогрешность вычислений: %f\n\n", exp(1), sum, i, e);
//Возврат программой нуля в знак успешного выполнения хода работы программы
	return 0;
//Точка выхода из программы
}

//Заголовок функции, вычисляющей число е методом ряда
float firstSeries(float e, int *i)
{
//Объявление локальной переменной sum - значение ряда (по умолчанию 0 - такое значение имеется при нулевой итерации)
	float sum = 2;
//Объявление локальной переменной temp - факториал
	int temp = 1;
//Присвоение счетчику переменных единицы
	*i = 1;
//Объявление локальной переменной sum - значение ряда (по умолчанию 2 - такое значение имеется при первой итерации)
//Точка входа в цикл с предусловием - вычисления продолжаются пока не вычислится значение соответствующее оригинальному в соотвествии с погршеностью
	while ((sum <= exp(1) - e) || (sum >= exp(1) + e))
	{
//Вычисление нового факториала
		temp *= ++(*i);
//Увеличение суммы ряда на новое слагаемое
		sum += 1.0 / temp;
//Точка выхода из цикла
	}
//Возврат функцией вычисленного значения
	return sum;
//Точка выхода из функции
}

//Заголовок функции, вычисляющей число е методом бесконечной дроби
float secondSeries(float e, int *i)
{
//Объявление локальной переменной sum - значение ряда (по умолчанию 0 - такое значение имеется при нулевой итерации)
	float sum = 0;
//Точка входа в цикл с предусловием - вычисления продолжаются пока не вычислится значение соответствующее оригинальному в соотвествии с погршеностью
	while ((sum <= exp(1) - e) || (sum >= exp(1) + e))
	{
//Вычисление нового приближения
		sum = infFrac(*i);
//Инкременция счетчика ряда
		(*i)++;
//Точка выхода из цикла
	}
//Возврат функцией вычисленного значения
	return sum;
//Точка выхода из функции	
}

//Функция, вычисляющая значение бесконечной дроби с заданной длиной
float infFrac(int i)
{
//оОбъявление локальных переменных temp (делитель получаемой суммы) и sum - значение дроби
	float temp, sum;
//Вычисление начального значения суммы
	sum = (float)i / (i + 2);
//Точка входа в цикл с предусловием - вычисления продолжаются пока постоянно уменьшающаяся итерация не станет равна единице
	while (i != 1)
	{
//Вычисление нового делителя бесконечной дроби
		temp = i-- + 1 - sum;
//Вычисление нового значения бесконечной дроби
		sum = (float)i / temp;
//Точка выхода из цикла
	}
//Последнее вычисление значения делителя
	temp = 1 - sum;
//Последнее значение вычисления суммы
	sum = 1.0 / temp;
//Возврат функцией вычисленного значения, увеличенного на единицу
	return sum + 1;
//Точка выхода из функции	
}
